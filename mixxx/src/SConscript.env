#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys, os, platform
import SCons.Script

#Import('platform')
#Import('machine')	#CPU architecture for optimization
#Import('architecture')	#CPU type & binary format for optimization
#Import('bitwidth')      #CPU bit width that can be forced (use this for most build items)

def determinePlatform():
	if os.name == 'nt':
		print 'Platform: Windows ' #+ machine + ' (' + architecture[0] + ')'
		platformString = 'windows'
	elif sys.platform == 'linux2':
		 print 'Platform: Linux '
		 platformString = 'linux'
	elif 'bsd' in sys.platform: #should cover {Net,Open,Free,DragonFly}BSD, but I'll be upfront: I've only built Mixxx on OpenBSD
		 print 'Platform: BSD '
		 platformString = 'bsd'
	elif sys.platform == 'darwin':
		 print 'Platform: OS X '
		 platformString = 'osx'
	else:
		print 'Platform: Unknown (assuming Linux-like,) ' + machine
		platformString = 'linux'

	Export('platformString')
	return platformString

def determineArchitecture(platformString):
	architecture = platform.architecture()
	machine = platform.machine()
	bitwidth = architecture[0][0:2];	# "32" or "64"

	Export('architecture')
	Export('machine')	#So architecture-specific decisions & optimizations can be made in the SConscript
	Export('bitwidth')

	# Allow to override auto-detection (environment variables must already be set appropriately with SETENV.CMD /xp /x86 or /x64)
	# (Auto-detection of 64-bit only works correctly if you're running a 64-bit version of Python, otherwise it'll see an x86 system)
	flags_force32 = ARGUMENTS.get('force32', 0)
	flags_force64 = ARGUMENTS.get('force64', 0)
	if int(flags_force32) and not int(flags_force64):
		if 'win' in platformString:
			machine = 'x86'
		else:
			env.Append(CCFLAGS = '-m32')
			env.Append(CXXFLAGS = '-m32')
			env.Append(LINKFLAGS = '-m32')
		bitwidth = '32'
		print 'FORCING ' +bitwidth+ '-BIT BUILD: ' + platformString + ' ' + machine + ' (' + bitwidth + 'bit)'

	#force 64-bit compile
	if int(flags_force64) and not int(flags_force32):
		if 'win' in platformString:
			machine = 'AMD64'
		else:
			env.Append(CCFLAGS = '-m64')
			env.Append(CXXFLAGS = '-m64')
			env.Append(LINKFLAGS = '-m64')
		bitwidth = '64'
		print 'FORCING ' +bitwidth+ '-BIT BUILD: ' + platformString + ' ' + machine + ' (' + bitwidth + 'bit)'

	print 'Binary format: ' + architecture[1]
	return {"machine":machine, "bitwidth":bitwidth}

def getBuildDir(platformString, bitwidth):
	build_dir = '%s%s_build' % (platformString[0:3],bitwidth)
	Export('build_dir')
	return build_dir

def getSVNRevision(): # GPL code taken from http://trac.zeitherrschaft.org/zzub/browser/trunk/SConstruct
	# if this is a repository, take the string from svnversion
	svnversionpath = env.WhereIs('svnversion', os.environ['PATH'])
	if os.path.isdir('../.svn') and (svnversionpath != None):  # we always start in .obj for some reason, so we must use ../.svn
		rev = os.popen('svnversion ..').readline().strip()
		if rev != "" and rev != "exported":
			return rev
	return ""

def getBZRRevision():
	return os.popen("bzr revno").readline().strip()

def getMixxxVersion():
	defs = File('#src/defs_version.h') #have to handle out-of-tree building, that's why the '#' :(
	#p = os.popen('grep -m 1 "#define VERSION" %s' % defs) #this is not cross-platform
	#version = p.readline()
	#p.close()

	for line in open(str(defs)).readlines():
		if line.strip().startswith("#define VERSION"):
			version = line
			break
	else:
		raise ValueError("Version not found")

	#given "#define VERSION "...."" extract "....":
	version = version.split()[-1].replace('"', '')
	return version

#Check for FFMPEG support
def CheckFFMPEG(conf, sources):
	flags['ffmpeg'] = ARGUMENTS.get('ffmpeg', 0)
	if int(flags['ffmpeg']):
		if platform == 'linux' or 'osx':
			#Check for libavcodec, libavformat
			#I just randomly picked version numbers lower than mine for this - Albert
			if not conf.CheckForPKG('libavcodec', '51.20.0'):
				print 'libavcodec not found.'
				Exit(1)
			if not conf.CheckForPKG('libavformat', '51.1.0'):
				print 'libavcodec not found.'
				Exit(1)
			else:
				#Grabs the libs and cflags for ffmpeg
				env.ParseConfig('pkg-config libavcodec --silence-errors --cflags --libs')
				env.ParseConfig('pkg-config libavformat --silence-errors --cflags --libs')
				env.Append(CPPDEFINES = '__FFMPEGFILE__')
		else:
			# aptitude install libavcodec-dev libavformat-dev liba52-0.7.4-dev libdts-dev
			env.Append(LIBS = 'avcodec')
			env.Append(LIBS = 'avformat')
			env.Append(LIBS = 'z')
			env.Append(LIBS = 'a52')
			env.Append(LIBS = 'dts')
			env.Append(LIBS = 'gsm')
			env.Append(LIBS = 'dc1394_control')
			env.Append(LIBS = 'dl')
			env.Append(LIBS = 'vorbisenc')
			env.Append(LIBS = 'raw1394')
			env.Append(LIBS = 'avutil')
			env.Append(LIBS = 'vorbis')
			env.Append(LIBS = 'm')
			env.Append(LIBS = 'ogg')
			env.Append(CPPDEFINES = '__FFMPEGFILE__')
		sources += Split("""soundsourceffmpeg.cpp """)
		print "Not working FFMPEG support... enabled"
	else:
		print "Not working FFMPEG support... disabled"
	return


# Checks for pkg-config on Linux
def CheckForPKGConfig( context, version='0.0.0' ):
	context.Message( "Checking for pkg-config (at least version %s)... " % version )
	ret = context.TryAction( "pkg-config --atleast-pkgconfig-version=%s" %version )[0]
	context.Result( ret )
	return ret

# Uses pkg-config to check for a minimum version
def CheckForPKG( context, name, version="" ):
	if version == "":
		context.Message( "Checking for %s... \t" % name )
		ret = context.TryAction( "pkg-config --exists '%s'" % name )[0]
	else:
		context.Message( "Checking for %s (%s or higher)... \t" % (name,version) )
		ret = context.TryAction( "pkg-config --atleast-version=%s '%s'" % (version,name) )[0]
		context.Result( ret )
	return ret

def getFlags(env, argflag, default=0):
	"""
	* get value passed as an argument to scons as argflag=value
	* if no value is passed to scons use stored value
	* if no value is stored, use default
	Returns the value and stores it in env[argflag]
	"""
	flags = ARGUMENTS.get(argflag, -1)
	if int(flags) < 0:
		if env.has_key(argflag):
			flags = env[argflag]
		else: #default value
			flags = default
	env[argflag] = flags
	return flags


flags = {}

#Determine our platform
platformString = determinePlatform()

#Figure out what the QT path is

default_qtdir = {'linux': '/usr/share/qt4',
		 'bsd': '/usr/local/lib/qt4',
		 'osx': '/usr/lib/Qt-4.5', #XXX this should be smarter, we just need qt4 so we should accept the highest version that matches /usr/lib/Qt-4.*.*/
		 'windows': 'C:\\qt\\4.5.1'}[platformString]	 #ditto

#Read the qtdir flag, if it was set explicitly
flags['qtdir'] = ARGUMENTS.get('qtdir', os.environ.get('QTDIR', default_qtdir)) #environ['QTDIR'] there is mainly for the benefit of MSVC
if not os.path.exists(flags['qtdir']):
	print "Error: QT path does not exist or QT4 is not installed."
	print "Please specify your QT path by running 'scons qtdir=[path]'"
	Exit(1)
elif flags['qtdir'].find("qt3") != -1 or flags['qtdir'].find("qt/3") != -1:
	print "Error: Mixxx now requires QT4 instead of QT3 - please use your QT4 path with the qtdir build flag."
	Exit(1)
else:
	print "QT path: " + flags['qtdir']



#Set up our environment, tell SCONS to use its QT tools, and set some enviroment variables for it.
#The ENV = os.environ part pulls in your existing environment variables. This is useful for awkward Linux setups
#and on Windows where all the paths are set in the shell.
if platformString in ('linux', 'bsd'):
	env = Environment(tools=['default','qt4'], toolpath=['#build/'], QTDIR=flags['qtdir'], ENV = os.environ)
	#Whoever hacked this in, it breaks scons for people who've set PKG_CONFIG_PATH in their shell. - Albert
 	#os.environ['PKG_CONFIG_PATH']=flags['qtdir']+'lib/pkgconfig'  #Set the PKG_CONFIG_PATH explicitly, handles multiple QT 4.x installations
elif platformString == 'osx':
	env = Environment(tools=['default', 'qt4', 'OSConsX'], toolpath=['#build/', '#/build/osx/'], ENV = os.environ)
elif 'win' in platformString:
	#Pull in the environment's variables for windows...
	env = Environment(tools=['default','qt4', 'msvs'], toolpath=['#build/'], QTDIR=flags['qtdir'], QT_LIB='', VCINSTALLDIR = os.getenv('VCInstallDir'), ENV = os.environ)
else:
	raise Exception("Unknown platform, didn't make a env variable. Crashing")

env['MIXXX_VERSION'] = getMixxxVersion() #should this be in the env?
env['CPPDEFINES'] = [''] #Initialize this as a list, fixes a bug where first CPPDEFINE would get mangled

#Figure out what architecture we are, set up bitwith and platform variables
arch_stuff = determineArchitecture(platformString)
machine = arch_stuff["machine"]
bitwidth = arch_stuff["bitwidth"]
build_dir = getBuildDir(platformString, bitwidth)

## Global cache directory
## Put all project files in it so a rm -rf cache will clean up the config
if not env.has_key('CACHEDIR'):
	env['CACHEDIR'] = str(Dir('#cache/'))
if not os.path.isdir(env['CACHEDIR']):
	os.mkdir(env['CACHEDIR'])

## Avoid spreading .sconsign files everywhere
#env.SConsignFile(env['CACHEDIR']+'/scons_signatures')
## WARNING - We found that the above line causes SCons to randomly not find
##           dependencies for some reason. It might not happen right away, but
##           a good number of users found that it caused weird problems - Albert (May 15/08)


#Hijack scons -h and --help
cachefile = str(env['CACHEDIR']) + 'custom.py'
#opts = Options(cachefile)
vars = Variables(cachefile)
vars.Add('prefix', 'Set to your install prefix', '/usr/local')
vars.Add('qtdir', 'Set to your QT4 directory', '/usr/share/qt4')
vars.Add('hifieq', 'Set to 1 to enable high quality EQs', 1)
vars.Add('ipod', 'Set to 1 to enable iPod support through libgpod', 0)
vars.Add('ladspa', '(EXPERIMENTAL) Set to 1 to enable LADSPA plugin support', 0)
vars.Add('ffmpeg', '(EXPERIMENTAL) Set to 1 to enable FFMPEG support', 0)
vars.Add('vinylcontrol', 'Set to 1 to enable vinyl control support', 1)
vars.Add('shoutcast', 'Set to 1 to enable shoutcast support', 0)
vars.Add('cmetrics', 'Set to 1 to enable crash reporting/usage statistics via Case Metrics (This should be disabled on development builds)', 0)
vars.Add('asmlib','Set to 1 to enable linking against Agner Fog\'s hand-optimized asmlib, found at http://www.agner.org/optimize/', 0)
vars.Add('script', 'Set to 1 to enable MixxxScript/QtScript Studio support.', 0)
vars.Add('midiscript', 'Set to 1 to enable MIDI Scripting support.', 1)
vars.Add('tonal', 'Set to 1 to enable tonal analysis', 0)
vars.Add('qdebug', 'Set to 1 to enable verbose console debug output.', 1)
vars.Add('test', 'Set to 1 to build Mixxx test fixtures.', 0)
if not 'win' in platformString:
	vars.Add('tuned', 'Set to 1 to optimize mixxx for this CPU (overrides "optimize")', 0)
	vars.Add('optimize', 'Set to:\n  1 for -O3 compiler optimizations\n  2 for Pentium 4 optimizations\n  3 for Intel Core optimizations\n  4 for Intel Core 2 optimizations\n  5 for Athlon-4/XP/MP optimizations\n  6 for K8/Opteron/AMD64 optimizations\n  7 for K8/Opteron/AMD64 w/ SSE3\n  8 for Celeron D (generic SSE/SSE2/SSE3) optimizations.', 1)
	vars.Add('profiling', '(DEVELOPER) Set to 1 to enable profiling using gprof (Linux) or Saturn (OS X)', 0)
else:
	if bitwidth == '64':
		vars.Add('tuned', 'Set to 1 to optimize mixxx for this CPU class', 0)
	vars.Add('optimize', 'Set to:\n  1 to maximize speed (/O2)\n  2 for maximum optimizations (/Ox)', 1)
	vars.Add('msvshacks', 'Set to 1 to build properly with MS Visual Studio 2005 (Express users should leave this off)', 0)
	vars.Add('msvcdebug', 'Set to 1 to link against MS libraries with debugging info (implies debug=1)', 0)
#env = Environment(options = opts)
vars.Update(env)
Help(vars.GenerateHelpText(env))

for getenv in ['CXXFLAGS', 'CCFLAGS', 'LINKFLAGS', 'LIBPATH', 'CPPPATH']:
	kwargs = {}
	if os.environ.has_key(getenv):
		kwargs[getenv] = SCons.Util.CLVar( os.environ[getenv] )
		env.Append(**kwargs)

#env.Append(CPPDEFINES=[('BUILD_REV', '"%s"' % getBZRRevision())]) #doing this forces a rebuild of everything whenever a commit happens -- not much fun
## instead, embed BZR version into build
## Put version info into a file, so it doesn't force a rebuild of everything :)
f = open("build.h","w")
try:
	f.write('#define BUILD_REV "' + getBZRRevision() + '"\n')
finally:
	f.close()

### embed SVN version into build
### Put version info into a file, so it doesn't force a rebuild of everything :)
#f = open("#.mixxx_version.h","w")
#try:
#	f.write('#define BUILD_REV "' + getSVNRevision() + '"\n')
#finally:
#	f.close()

#Mixxx sources to build
sources = Split("""

                input.cpp
                mixxxkeyboard.cpp
                configobject.cpp
                controlobjectthread.cpp
                controlobjectthreadwidget.cpp
                controlobjectthreadmain.cpp
                controlevent.cpp
                controllogpotmeter.cpp
                controlobject.cpp
                controlnull.cpp
                controlpotmeter.cpp
                controlpushbutton.cpp
                controlttrotary.cpp
                controlbeat.cpp

                dlgpreferences.cpp
                dlgprefsound.cpp
                dlgprefmidibindings.cpp
                dlgprefplaylist.cpp
                dlgprefnomidi.cpp
                dlgprefcontrols.cpp
                dlgprefbpm.cpp
                dlgbpmscheme.cpp
                dlgabout.cpp
                dlgprefeq.cpp
                dlgprefcrossfader.cpp
                dlgmidilearning.cpp
                dlgtrackinfo.cpp
                dlgprepare.cpp
                dlgautodj.cpp

                engine/engineworker.cpp
                engine/engineworkerscheduler.cpp
                engine/enginebuffer.cpp
                engine/enginebufferscale.cpp
		engine/enginebufferscaledummy.cpp
                engine/enginebufferscalelinear.cpp
		engine/enginebufferscalereal.cpp
                engine/engineclipping.cpp
                engine/enginefilterblock.cpp
                engine/enginefilteriir.cpp
                engine/enginefilter.cpp
                engine/engineobject.cpp
                engine/enginepregain.cpp
                engine/enginevolume.cpp
                engine/enginechannel.cpp
                engine/enginemaster.cpp
                engine/enginedelay.cpp
                engine/engineflanger.cpp
                engine/enginespectralfwd.cpp
                engine/enginevumeter.cpp
                engine/enginevinylsoundemu.cpp
                engine/enginesidechain.cpp
                engine/enginefilterbutterworth8.cpp
                engine/enginexfader.cpp
                engine/enginecontrol.cpp
                engine/ratecontrol.cpp
                engine/loopingcontrol.cpp
                engine/bpmcontrol.cpp
                engine/cuecontrol.cpp
                engine/readaheadmanager.cpp
                cachingreader.cpp

                analyserqueue.cpp
				analyserwavesummary.cpp
				analyserbpm.cpp
				analyserwaveform.cpp
                midi/midimapping.cpp
                midi/midiinputmappingtablemodel.cpp
                midi/midioutputmappingtablemodel.cpp
                midi/midichanneldelegate.cpp
                midi/midistatusdelegate.cpp
                midi/midinodelegate.cpp
                midi/midioptiondelegate.cpp
                midi/midimessage.cpp
                midi/midiledhandler.cpp

                main.cpp
                controlgroupdelegate.cpp
                controlvaluedelegate.cpp
                mixxxcontrol.cpp
                mixxx.cpp
                mixxxview.cpp
                errordialoghandler.cpp
                upgrade.cpp

                soundsource.cpp
                soundsourcemp3.cpp
                soundsourceoggvorbis.cpp

                widget/wwidget.cpp
                widget/wlabel.cpp
                widget/wnumber.cpp
                widget/wnumberpos.cpp
                widget/wnumberrate.cpp
                widget/wnumberbpm.cpp
                widget/wknob.cpp
                widget/wdisplay.cpp
                widget/wvumeter.cpp
                widget/wpushbutton.cpp
                widget/wslidercomposed.cpp
                widget/wslider.cpp
                widget/wstatuslight.cpp
				widget/woverview.cpp
				widget/wskincolor.cpp
				widget/wabstractcontrol.cpp
                widget/wsearchlineedit.cpp
				widget/wpixmapstore.cpp
				widget/hexspinbox.cpp
				widget/wsampler.cpp
                sampleutil.cpp
                mathstuff.cpp
                rtthread.cpp
                windowkaiser.cpp
                probabilityvector.cpp

                peaklist.cpp
                rotary.cpp
                wtracktableview.cpp
                widget/wtracktableviewheader.cpp
                widget/wlibrarysidebar.cpp
                widget/wlibrary.cpp
                widget/wlibrarytableview.cpp
                widget/wpreparelibrarytableview.cpp
                widget/wpreparecratestableview.cpp
                widget/wbrowsetableview.cpp
                widget/wlibrarytextbrowser.cpp
                library/preparecratedelegate.cpp
                library/trackcollection.cpp
                library/basesqltablemodel.cpp
                library/librarytablemodel.cpp
                library/preparelibrarytablemodel.cpp
                library/browsetablemodel.cpp
                library/missingtablemodel.cpp
                library/proxytrackmodel.cpp
                library/abstractxmltrackmodel.cpp
                library/rhythmboxtrackmodel.cpp
                library/rhythmboxplaylistmodel.cpp
                library/itunestrackmodel.cpp
                library/itunesplaylistmodel.cpp
                library/playlisttablemodel.cpp
                library/libraryfeature.cpp
                library/preparefeature.cpp
                library/autodjfeature.cpp
                library/mixxxlibraryfeature.cpp
                library/playlistfeature.cpp
                library/rhythmboxfeature.cpp
                library/itunesfeature.cpp
                library/browsefeature.cpp
                library/cratefeature.cpp
                library/browsefilter.cpp
                library/sidebarmodel.cpp
                library/libraryscanner.cpp
                library/libraryscannerdlg.cpp
                library/legacylibraryimporter.cpp
                library/library.cpp
                library/searchthread.cpp
                library/dao/cratedao.cpp
                library/cratetablemodel.cpp
                library/dao/cuedao.cpp
                library/dao/cue.cpp
                library/dao/trackdao.cpp
                library/dao/playlistdao.cpp
                library/dao/libraryhashdao.cpp
                library/dao/settingsdao.cpp
                library/librarymidicontrol.cpp
                library/schemamanager.cpp
                library/promotracksfeature.cpp
                library/promotrackswebview.cpp
                xmlparse.cpp
                parser.cpp
                parserpls.cpp
                parserm3u.cpp

                bpm/bpmscheme.cpp

                soundsourceproxy.cpp

                widget/wvisualsimple.cpp
                widget/wwaveformviewer.cpp
                widget/wglwaveformviewer.cpp
                waveformviewerfactory.cpp
                waveform/renderobject.cpp
                waveform/waveformrenderer.cpp
		waveform/waveformrenderbackground.cpp
		waveform/waveformrendersignal.cpp
                waveform/waveformrendersignaltiles.cpp
		waveform/waveformrendersignalpixmap.cpp
		waveform/waveformrendermark.cpp
                waveform/waveformrendermarkrange.cpp
                waveform/waveformrenderbeat.cpp


                imginvert.cpp
                imgloader.cpp
                imgcolor.cpp

                trackinfoobject.cpp
                player.cpp
                playermanager.cpp
				sampler.cpp
				samplermanager.cpp
                sounddevice.cpp
                soundmanager.cpp
                sounddeviceportaudio.cpp
                dlgprefrecord.cpp
                recording/enginerecord.cpp
                recording/writeaudiofile.cpp
                playerinfo.cpp

                segmentation.cpp
                """)

#Set up the library path on Windows:
if 'win' in platformString:
	env.Append(CPPPATH='#/../mixxx-win' + bitwidth + 'lib-msvc') #If you add more directories, separate them with a semicolon (;)
	env.Append(LIBPATH='#/../mixxx-win' + bitwidth + 'lib-msvc')
	env.Append(CPPPATH='../../lib/ladspa') #If you add more directories, separate them with a semicolon (;)
	env.Append(LINKFLAGS = ['/nodefaultlib:libc.lib', '/nodefaultlib:libcd.lib',  '/entry:mainCRTStartup'])
	env.Append(LIBS='advapi32') # needed for PortMIDI
#'/subsystem:windows',

if platformString == 'bsd':
	env.Append(CPPPATH=['/usr/include', '/usr/local/include', '/usr/X11R6/include/'])
	env.Append(LIBPATH=['/usr/lib/', '/usr/local/lib', '/usr/X11R6/lib'])
#BSD hacks
#XXX todo: move these into their proper places

	env.Append(LIBS='pthread')
	env.Append(LIBS=['ogg', 'vorbis']) #why do we need to do this on OpenBSD and not on Linux? if we don't then CheckLib("vorbisfile") fails
elif platformString == 'osx':
	#Non-standard libpaths for fink and certain (most?) darwin ports
	env.Append(LIBPATH = ['/sw/lib'])
	env.Append(CPPPATH = ['/sw/include'])

	#Non-standard libpaths for darwin ports
	env.Append(LIBPATH = ['/opt/local/lib'])
	env.Append(CPPPATH = ['/opt/local/include'])


#Check for dependencies if we're not doing a clean...
#if not env.GetOption('clean') and not SCons.Util.containsAny(os.sys.argv, ['-h', '--help']):
conf = Configure(env, custom_tests = { 'CheckForPKGConfig' : CheckForPKGConfig, 'CheckForPKG' : CheckForPKG })

#TODO: Add all of the other configure checks as custom_tests properly.

# On Posix default SCons.LIBPREFIX = 'lib', on Windows default SCons.LIBPREFIX = ''

#XXX all these Exit(1) calls should be turned into a list of libs to look for and then a loop that does the exit if any(conf.CheckLib(lib) for lib in list)
if not conf.CheckLib('portaudio'):
	print 'Did not find libportaudio.a, portaudio.lib, or the PortAudio-v19 development header files - exiting!'
	Exit(1)

if not conf.CheckLib(['id3tag','libid3tag-release']):
	print 'Did not find libid3tag.a, libid3tag.lib, or the libid3tag development header files - exiting!'
	Exit(1)

if not conf.CheckLib(['mad','libmad']):
	print 'Did not find libmad.a, libmad.lib, or the libmad development header files - exiting!'
	Exit(1)

#Check for libsndfile
#if not conf.CheckLibWithHeader(['sndfile', 'libsndfile'], 'sndfile.h', 'C'):
if not conf.CheckLib(['sndfile', 'libsndfile']):
	print "Did not find libsndfile or it\'s development headers, exiting!"
	Exit(1)
else:
	#env.Append(LIBS='sndfile') #XXX is this necessary?
	env.Append(CPPDEFINES = '__SNDFILE__')
	sources.append('soundsourcesndfile.cpp') ## TODO: Convert this to a SharedLibrary, so it can be installed without having to run scons twice after a clean


#Check for Ogg and Vorbis
if platformString == 'windows' and bitwidth == '64':
	if not conf.CheckLib('vorbisfile_static'): # For some reason this has to be checked this way on win64, otherwise it looks for the dll lib which will cause a conflict later (at line 713)
		print 'Did not find vorbisfile_static.lib or the libvorbisfile development headers, exiting!'
		Exit(1)
else:
	if not conf.CheckLib('vorbisfile'):
		print 'Did not find libvorbisfile.a, libvorbisfile.lib, or the libvorbisfile development headers, exiting!'
		Exit(1)

if not conf.CheckLib('vorbis'):
	print 'Did not find libvorbis.a, libvorbis.lib, or the libvorbisfile development headers, exiting!'
	Exit(1)

if not conf.CheckLib('ogg'):
	print 'Did not find libogg.a, libogg.lib, or the libogg development headers, exiting!'
	Exit(1)


## Check for OpenGL (it's messy to do it for all three platforms)
## XXX this should *NOT* have hardcoded paths like this
if not conf.CheckLib('GL') and not conf.CheckCHeader('GL/gl.h') and not conf.CheckLib('opengl32') and not conf.CheckCHeader('/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers/gl.h'):
	print 'Did not find OpenGL development files, exiting!'
	Exit(1)

if not conf.CheckLib('GLU') and not conf.CheckCHeader('GL/glu.h') and not conf.CheckLib('glu32') and not conf.CheckCHeader('/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers/glu.h'):
	print 'Did not find GLU development files, exiting!'
	Exit(1)

#Check if FFMPEG was enabled
CheckFFMPEG(conf, sources)

#Check for PortTime
if not conf.CheckLib(['porttime', 'libporttime']) and not conf.CheckHeader(['porttime.h']):
	print "Did not find PortTime or its development headers, exiting!"
	Exit(1)

#Check for PortMIDI & PortTime
if not conf.CheckLib(['portmidi', 'libportmidi']) and not conf.CheckHeader(['portmidi.h']):
 	print "Did not find PortMidi or its development headers, exiting!"
 	Exit(1)


sources += Split("""midi/mididevice.cpp """);
sources += Split("""midi/mididevicemanager.cpp """);
sources += Split("""midi/midideviceportmidi.cpp """);

#Platform-specific checks for Linux...
if platformString == 'linux':
	#Check for g++ (yeah, SCONS is a bit dumb here)
	if os.system("which g++ > /dev/null"): #Checks for non-zero return code
		print "Did not find g++, exiting!"
		Exit(1)

	#Check for pkg-config
	if not conf.CheckForPKGConfig('0.15.0'):
		print 'pkg-config >= 0.15.0 not found.'
		Exit(1)

	#Check for QT >= 4.3
	if not conf.CheckForPKG('QtCore', '4.3'):
		print 'QT >= 4.3 not found.'
		Exit(1)
	else:
		#Grabs the QT4 include paths
		"""
		env.ParseConfig('pkg-config QtCore --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config Qt3Support --silence-errors --cflags') #QT3 support breaks the build
		env.ParseConfig('pkg-config QtSql --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtGui --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtXml --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtOpenGL --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtScript --silence-errors --cflags --libs')
		"""
		#Try using David's qt4.py's Qt4-module finding thingy instead of pkg-config.
		#(This hopefully respects our qtdir=blah flag while linking now.)

		env.EnableQt4Modules([
		'QtCore',
		'QtGui',
		'QtOpenGL',
		'Qt3Support',
		'QtXml',
		'QtSvg',
		'QtSql',
		'QtScript',
		'QtXmlPatterns',
		'QtWebKit'
		#'QtUiTools',
		#'QtDesigner',
		#'QtWebKit',
		],
		debug=False,
		)

	#Another check for PortAudio-v19 # why? -kousu
	env.ParseConfig('pkg-config --cflags --libs portaudio-2.0')
		#If the above line looks like magic, it's because it really is. (Read about ParseConfig, it's nifty)

#Platform-specific checks for OS X
if platformString == 'osx':

	env.Append(CPPPATH='/Library/Frameworks/OpenGL.framework/Headers/')
	env.Append(LINKFLAGS='-framework OpenGL')

	#QT4
	env.Append(LINKFLAGS = '-framework QtCore -framework QtOpenGL -framework Qt3Support -framework QtGui -framework QtSql -framework QtXml -framework QtXmlPatterns  -framework QtNetwork -framework QtSql -framework QtScript -framework QtWebKit')
	env.Append(CPPPATH = ['/Library/Frameworks/QtCore.framework/Headers/',
				'/Library/Frameworks/QtOpenGL.framework/Headers/',
				'/Library/Frameworks/Qt3Support.framework/Headers/',
				'/Library/Frameworks/QtGui.framework/Headers/',
				'/Library/Frameworks/QtXml.framework/Headers/',
				'/Library/Frameworks/QtNetwork.framework/Headers/',
				'/Library/Frameworks/QtSql.framework/Headers/',
				'/Library/Frameworks/QtWebKit.framework/Headers/',
				'/Library/Frameworks/QtScript.framework/Headers/'])

	#Non-standard libpaths for fink and darwin ports
	env.Append(LIBPATH = ['/sw/lib'])
	env.Append(CPPPATH = ['/sw/include'])

	#Check for CoreMIDI
	if not conf.CheckCXXHeader('/System/Library/Frameworks/CoreMIDI.framework/Headers/CoreMIDI.h'):
		print 'Did not find CoreMIDI framework, exiting! (Please install it)'
		Exit(1)
	else:
		env.Append(LINKFLAGS = '-framework CoreMIDI -framework CoreFoundation -framework CoreAudio -framework Carbon -framework QuickTime -framework AudioToolbox -framework AudioUnit') #Have to add the rest of these frameworks somewhere..


#hack: check for these here, before conf.Finish happens
have_mp4v2_h = conf.CheckHeader('mp4v2/mp4v2.h')
have_mp4 = (have_mp4v2_h and conf.CheckLib(['mp4v2', 'libmp4v2'])) or conf.CheckLib('mp4')

# We have to check for libfaad version 2.6 or 2.7. In libfaad
# version 2.7, the type for the samplerate is unsigned long*,
# while in 2.6 the type is uint32_t*. We can use the optional
# call parameter to CheckLibWithHeader to build a test file to
# check which one this faad.h supports.

have_faad = conf.CheckLib(['faad', 'libfaad'])
have_faad_26 = False

# Check for libfaad version 2.6. This check doesn't work correctly on Windows
# And we build it manually anyway, so we know it's v2.7
if have_faad and 'win' not in platformString:
	have_faad_26 = (not conf.CheckLibWithHeader(
                        'libfaad', 'faad.h', 'c++',
                        call = 'faacDecInit2(0, 0, 0, (unsigned long*)0, (unsigned char*)0);',
                        autoadd=False))

have_m4a = have_mp4 and have_faad
flags['m4a'] = getFlags(env, 'm4a', 0)
if int(flags['m4a']) and not have_m4a:
        if not have_mp4:
                print 'Did not find libmp4v2 or the libmp4v2 development headers, exiting!'
        if not have_faad:
                print 'Did not find libfaad or the libfaad development headers, exiting!'
        Exit(1)


env = conf.Finish()

#Declare the flags for Mixxx's config/track listing files:
#The quotes are necessary, since these are used directly in C code as strings
if platformString in ('linux', 'bsd'):
        _mixxx_files = [('SETTINGS_PATH','.mixxx/'), ('BPMSCHEME_FILE','mixxxbpmscheme.xml'), ('SETTINGS_FILE', 'mixxx.cfg'), ('TRACK_FILE', 'mixxxtrack.xml')]
elif platformString == 'osx': #right now this is the same as linux and bsd, but these files should really go in ~/Library/Applicationsomething like the rest of OS X apps do
        _mixxx_files = [('SETTINGS_PATH','.mixxx/'), ('BPMSCHEME_FILE', 'mixxxbpmscheme.xml'), ('SETTINGS_FILE', 'mixxx.cfg'), ('TRACK_FILE', 'mixxxtrack.xml')]
elif 'win' in platformString:
        _mixxx_files = [('SETTINGS_PATH','Local Settings/Application Data/Mixxx/'), ('BPMSCHEME_FILE', 'mixxxbpmscheme.xml'), ('SETTINGS_FILE', 'mixxx.cfg'), ('TRACK_FILE', 'mixxxtrack.xml')]
_mixxx_files = [(k, r'\"' + v + r'\"') for k,v in _mixxx_files] #escape the filepaths, so that they wind up as C-strings to the C-compiler (the \s are so the shell doesn't eat the ")
env.Append(CPPDEFINES=_mixxx_files)
del _mixxx_files #safety net

# say where to find resources on Unix
# XXX we should replace this with a RESOURCES_PATH and covers Win and OS X too
if platformString in ('linux', 'bsd'):
	env.Append(CPPDEFINES=('UNIX_SHARE_PATH', r'\"' + os.path.join(ARGUMENTS.get('prefix', '/usr/local'),'share/mixxx') + r'\"'))

#declare platform specific flags? though we shouldn't really need these, the compilers should Just Know...
#on __APPLE__ it works like that. probably we just need to look into what the default __platform__ #defines are and search and replace in the code
env.Append(CPPDEFINES=machine)

if platformString == 'linux':
	env.Append(CPPDEFINES='__LINUX__')
elif platformString == 'bsd':
	env.Append(CPPDEFINES='__BSD__')
elif 'win' in platformString:
	env.Append(CPPDEFINES='__WINDOWS__')
	env.Append(CPPDEFINES='UNICODE')	# Need this on Windows until we have UTF16 support in Mixxx
	env.Append(CPPDEFINES='WIN'+bitwidth)

if platformString in ('linux', 'bsd'): #a define for code that works on unix only can ask for (not sure if this is actually used anywhere)
	env.Append(CPPDEFINES='__UNIX__')

env.Append(CPPDEFINES = '__PORTAUDIO__'); #Turn on PortAudio support in Mixxx
env.Append(CPPPATH = ['.', '../', '../../']) #Fun fun fun with paths


if platformString in ('linux', 'bsd'):
	env.Append(LIBS = 'Qt3Support')
	env.Append(LIBS = 'QtXml')
	env.Append(LIBS = 'QtGui')
	env.Append(LIBS = 'QtCore')
	env.Append(LIBS = 'QtNetwork')
	env.Append(LIBS = 'QtOpenGL')
	env.Append(LIBS = 'QtWebKit')
	env.Append(LIBS = 'QtScript')
	env.Append(LIBS = 'sndfile') #? we shouldn't have to do this...
	env.Append(LIBS = 'vorbisfile') #? we shouldn't have to do this...

if 'win' in platformString:
	env.Append(LIBS = 'Qt3Support4'); #Windows needs this instead of 'Qt3Support'
	env.Append(LIBS = 'QtXml4');
	env.Append(LIBS = 'QtXmlPatterns4');
	env.Append(LIBS = 'QtSql4');
	env.Append(LIBS = 'QtGui4');
	env.Append(LIBS = 'QtCore4');
	env.Append(LIBS = 'QtWebKit4');
	env.Append(LIBS = 'QtOpenGL4');
	env.Append(LIBS = 'WinMM'); #Needed for Midi stuff
	env.Append(LIBS = 'ogg_static')
	env.Append(LIBS = 'vorbis_static')
	env.Append(LIBS = 'vorbisfile_static')
	env.Append(LIBS = 'imm32')
	env.Append(LIBS = 'wsock32')
	env.Append(LIBS = 'delayimp')
	env.Append(LIBS = 'winspool')
	env.Append(LIBS = 'shell32')

env.Append(CPPDEFINES = ['QT3_SUPPORT', 'QT3_SUPPORT_WARNINGS', 'QT_THREAD_SUPPORT', 'QT_SHARED', 'QT_TABLET_SUPPORT']) #Stolen from Mixxx's build output

if platformString in ('linux','bsd') or 'win' in platformString:
	env.Append(CPPPATH=['$QTDIR/include/Qt3Support',
			    '$QTDIR/include/QtCore',
			    '$QTDIR/include/QtGui',
			    '$QTDIR/include/QtXml',
			    '$QTDIR/include/QtNetwork',
			    '$QTDIR/include/QtSql',
			    '$QTDIR/include/QtOpenGL',
			    '$QTDIR/include/QtWebKit',
			    '$QTDIR/include/Qt'])

if 'win' in platformString:
	env.Append(CPPPATH=["$VCINSTALLDIR/include/atl", "C:/Program Files/Microsoft Platform SDK/Include/atl"])
	env.Append(CPPDEFINES = 'WIN'+bitwidth) #for soundtouch
else:
	env.Append(CCFLAGS = Split(""" -pipe -Wall -W -g """)) # omghax
	env.Append(LINKFLAGS = Split(""" -pipe -Wall -W -g"""))
	if platformString != 'osx':
		env.Append(LINKFLAGS = "-Wl,-rpath,$QTDIR/lib")
	env.Append(LINKFLAGS = "-Wl,-rpath,$QTDIR/lib")
	env.Append(CPPDEFINES = "_REENTRANT")

#Uic these guys (they're moc'd automatically after this) - Generates the code for the QT UI forms
env.Uic4('dlgpreferencesdlg.ui')
env.Uic4('dlgprefsounddlg.ui')
env.Uic4('dlgprefmidibindingsdlg.ui')
env.Uic4('dlgprefplaylistdlg.ui')
env.Uic4('dlgprefnomididlg.ui')
env.Uic4('dlgprefcontrolsdlg.ui')
env.Uic4('dlgprefeqdlg.ui')
env.Uic4('dlgprefcrossfaderdlg.ui')
env.Uic4('dlgprefbpmdlg.ui')
env.Uic4('dlgbpmschemedlg.ui')
# env.Uic4('dlgbpmtapdlg.ui')
env.Uic4('dlgprefvinyldlg.ui')
env.Uic4('dlgprefrecorddlg.ui')
env.Uic4('dlgaboutdlg.ui')
env.Uic4('dlgmidilearning.ui')
env.Uic4('dlgtrackinfo.ui')
env.Uic4('dlgprepare.ui')
env.Uic4('dlgautodj.ui')

#Add the QRC file which compiles in some extra resources (prefs icons, etc.)
env.Qrc('#res/mixxx.qrc')
sources += Split(""" #res/qrc_mixxx.cc """)

if 'win' in platformString:
	env.RES('mixxx.rc')
	sources += Split(""" mixxx.res """)

#Tell SCons to build libraries that are bundled with Mixxx
#===================================================

#SoundTouch
#XXX this should be done with a subsconscript

soundtouch_path = 'soundtouch-1.4.1'

env.Append(CPPPATH=['#lib/'+soundtouch_path])
sources += Split("""engine/enginebufferscalest.cpp
                    #lib/""" + soundtouch_path + """/SoundTouch.cpp
                    #lib/""" + soundtouch_path + """/TDStretch.cpp
                    #lib/""" + soundtouch_path + """/RateTransposer.cpp
                    #lib/""" + soundtouch_path + """/AAFilter.cpp
                    #lib/""" + soundtouch_path + """/FIFOSampleBuffer.cpp
                    #lib/""" + soundtouch_path + """/FIRFilter.cpp
                    #lib/""" + soundtouch_path + """/PeakFinder.cpp
                    #lib/""" + soundtouch_path + """/BPMDetect.cpp
                    """)

if 'win' in platformString:
	if bitwidth == '64':
		sources += Split("""#lib/""" + soundtouch_path + """/cpu_detect_x64_win.cpp""")
	else:
		sources += Split("""#lib/""" + soundtouch_path + """/cpu_detect_x86_win.cpp""")
else:
	if bitwidth == '64':
		sources += Split("""#lib/""" + soundtouch_path + """/cpu_detect_x64_gcc.cpp""")
	else:
		sources += Split("""#lib/""" + soundtouch_path + """/cpu_detect_x86_gcc.cpp""")


#KissFFT
env.Append(CPPPATH=['#lib/kissfft'])
sources += Split("""#lib/kissfft/kiss_fft.c""")

#libsamplerate - Getting rid of this out of our source tree since we don't use it.
#env.Append(CPPPATH='#lib/libsamplerate')
#sources += Split("""engine/enginebufferscalesrc.cpp #lib/libsamplerate/samplerate.c #lib/libsamplerate/src_linear.c #lib/libsamplerate/src_sinc.c #lib/libsamplerate/src_zoh.c""")

#fidlib (for EQs)
#XXX this should be a SharedLib() line
env.Append(CPPPATH='#lib/fidlib-0.9.9/')
sources += Split("""#lib/fidlib-0.9.9/fidlib.c """)

## Platform-specific compile/link flags needed for fidlib
if 'win' in platformString:
	env.Append(CPPDEFINES = 'T_MSVC')
	#env.Append(CXXFLAGS = '-DT_MSVC') #is this still needed?
	env.Append(LINKFLAGS = ['/nodefaultlib:LIBCMT.lib', '/nodefaultlib:LIBCMTD.lib'])
	env.Append(CXXFLAGS = '/Zc:wchar_t-') #Ugh, MSVC-only hack :( see http://www.qtforum.org/article/17883/problem-using-qstring-fromstdwstring.html
else:
	env.Append(CPPDEFINES = 'T_LINUX') #so maybe "T_LINUX" isn't really accurate for an else case, but the only platforms really in existence are Unix and Win right now, and that's all we're targetting


#Parse command-line build flags
build_flags = ""

print "\nFeatures Summary:\n================"


#High quality EQs
flags['hifieq'] = getFlags(env, 'hifieq', 1)
if int(flags['hifieq']) == 0:
	env.Append(CPPDEFINES = ['__LOFI__', '__NO_INTTYPES__']) #Enables old crappy EQs
	print "High quality EQs... disabled"
else:
	print "High quality EQs... enabled"
	build_flags += 'hifieq '

#Experimental IPOD support
flags['ipod'] = getFlags(env, 'ipod', 0)
if int(flags['ipod']):
	env.Append(CPPDEFINES = '__IPOD__')

	if 'win' in platformString:
		env.Append(LIBS = 'gpod');
		# You must check v-this-v directory out from http://publicsvn.songbirdnest.com/vendor-binaries/trunk/windows-i686-msvc8/libgpod/
		env.Append(LIBPATH='../../../windows-i686-msvc8/libgpod/release/lib')
		# Following building the following must be added to the dist folder in order for mixxx to run with ipod support on Windows
		# \windows-i686-msvc8\libgpod\release\lib\libgpod.dll
		# \windows-i686-msvc8\glib\release\bin\libgobject-2.0-0.dll
		# \windows-i686-msvc8\glib\release\bin\libglib-2.0-0.dll
		# \windows-i686-msvc8\libiconv\release\bin\iconv.dll
		# \windows-i686-msvc8\gettext\release\binintl.dll
	if platformString == 'linux' or platformString == 'osx':
		# env.Append(LIBS = 'libgpod-1.0')
		# env.Append(LIBS = 'glib-2.0')
		env.ParseConfig('pkg-config libgpod-1.0 --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config glib-2.0 --silence-errors --cflags --libs')

	sources += Split("""wipodtracksmodel.cpp """) #IPOD
	print "iPod support... enabled"
	build_flags += 'ipod '
else:
	print "iPod support... disabled"

#Experimental Shoutcast
flags['shoutcast'] = getFlags(env, 'shoutcast', 0)

if int(flags['shoutcast']):
	shoutmp3 = 0
	shoutogg = 0

	conf = Configure(env, custom_tests = { 'CheckForPKGConfig' : CheckForPKGConfig, 'CheckForPKG' : CheckForPKG })
	if not conf.CheckLib('shout'):
		print "libshout was not found! Please install it or compile Mixxx without Shoutcast support using the shoutcast=0 flag."
		Exit(1)

	env.Append(CPPDEFINES = '__SHOUTCAST__')

	sources += Split(""" dlgprefshoutcast.cpp engine/engineshoutcast.cpp encoder.cpp """ )
	build_flags += 'shoutcast '


	if conf.CheckLibWithHeader('mp3lame', 'lame/lame.h', 'C'):
		env.Append(CPPDEFINES = '__SHOUTCAST_LAME__')
		sources += Split(""" encodermp3.cpp """)
		shoutmp3 = 1

	if conf.CheckLib('vorbisenc'):
		env.Append(CPPDEFINES = '__SHOUTCAST_VORBIS__')
		sources += Split("""  encodervorbis.cpp """)
		shoutogg = 1


	if shoutmp3 and shoutogg:
		print "Shoutcast support (OGG/MP3)... enabled"
	elif shoutmp3:
		print "Shoutcast support (MP3)... enabled"
	elif shoutogg:
		print "Shoutcast support (OGG)... enabled"
	else:
		print "Shoutcast support... enabled"

	env.Uic4('dlgprefshoutcastdlg.ui')

else:
	print "Shoutcast support... disabled"

#LADSPA
flags['ladspa'] = getFlags(env, 'ladspa', 0)
if int(flags['ladspa']):
	env.Append(CPPPATH=['#lib/ladspa']) #If you add more directories, separate them with a semicolon (;)
	env.Append(CPPDEFINES = '__LADSPA__')
	sources += Split("""engine/engineladspa.cpp
                            ladspa/ladspaloader.cpp
                            ladspa/ladspalibrary.cpp
                            ladspa/ladspaplugin.cpp
                            ladspa/ladspainstance.cpp
                            ladspa/ladspacontrol.cpp
                            ladspa/ladspainstancestereo.cpp
                            ladspa/ladspainstancemono.cpp
                            ladspaview.cpp
                            ladspa/ladspapreset.cpp
                            ladspa/ladspapresetmanager.cpp
                            ladspa/ladspapresetknob.cpp
                            ladspa/ladspapresetinstance.cpp
                            dlgladspa.cpp
                            ladspa/ladspapresetslot.cpp
                            """)
	plugins += SConscript(File('#lib/ladspa/SConscript'))
	env.Alias('plugins', plugins)
	print "LADSPA support... enabled"
	build_flags += 'ladspa '
else:
	print "LADSPA support... disabled"

#Vinyl Control
flags['vinylcontrol'] = getFlags(env, 'vinylcontrol', 1)
if int(flags['vinylcontrol']):
	env.Append(CPPDEFINES = '__VINYLCONTROL__')
	sources += Split(""" vinylcontrol.cpp vinylcontrolproxy.cpp vinylcontrolscratchlib.cpp vinylcontrolxwax.cpp dlgprefvinyl.cpp vinylcontrolsignalwidget.cpp engine/enginevinylcontrol.cpp """)
	env.Append(CPPPATH='#lib/xwax')
	if 'win' in platformString:
		sources += Split("""#lib/xwax/timecoder_win32.c """)
	else:
		sources += Split("""#lib/xwax/timecoder.c """)
	env.Append(CPPPATH='#lib/scratchlib')
	sources += Split("""#lib/scratchlib/DAnalyse.cpp """)
	print "Vinyl Control... enabled"
	build_flags += 'vinylcontrol '
else:
	print "Vinyl Control... disabled"

flags['msvcdebug'] = getFlags(env, 'msvcdebug', 0)
if 'win' in platformString:
	if int(flags['msvcdebug']):
		env.Append(CCFLAGS = '/MDd') # required for sndfile w/ flac support on windows
		env.Append(LINKFLAGS = '/DEBUG')
		if bitwidth == '64':
			env.Append(CXXFLAGS = '/Zi')
			env.Append(LINKFLAGS = '/NODEFAULTLIB:MSVCRT')
		else:
			env.Append(CXXFLAGS = '/ZI')
		print "MSVC Debugging... enabled"
		build_flags += 'msvcdebug '
	else:
		env.Append(LINKFLAGS = '/subsystem:windows')
		env.Append(CCFLAGS = '/MD') # required for sndfile w/ flac support on windows
		print "MSVC Debugging... disabled"


flags['tonal'] = getFlags(env, 'tonal', 0)
if int(flags['tonal']):
	print "Tonal analysis... enabled"
	build_flags += 'tonal '
	sources += Split("""tonal/FourierTransform.cxx tonal/Segmentation.cxx
			tonal/tonalanalyser.cpp tonal/ConstantQTransform.cxx
			tonal/ConstantQFolder.cxx""")
else:
	print "Tonal analysis... disabled"



flags['m4a'] = getFlags(env, 'm4a', 0)
if int(flags['m4a']):
	print "Apple M4A audio file support...",
	if have_m4a:
		print "enabled"

		# If the compile did not work, then enable the M4AHACK define.
		if have_faad_26:
			env.Append(CPPDEFINES = '__M4AHACK__')
			print "libfaad 2.6 compatibility mode... enabled"

		if have_mp4v2_h:
			env.Append(CPPDEFINES = '__MP4V2__')

	#	env.ParseConfig('pkg-config libmp4v2-dev --silence-errors --cflags --libs') # no pkg-config data for libmp4v2-dev
	#	FIXME: should do conf.CheckCHeader('mp4.h') or something...
		env.Append(CPPDEFINES = '__M4A__')
		build_flags += 'm4a '
		env.Append(LIBS = 'libmp4v2')
		env.Append(LIBS = 'libfaad')
	else:
		print "not found (did you install libmp4v2 and libfaad?)"
else:
	print "Apple M4A audio file support... disabled"



def build_gtest():
	gtest_dir = env.Dir("#lib/gtest-1.3.0")
	gtest_dir.addRepository(env.Dir('#lib/gtest-1.3.0'))
	#env['EXE_OUTPUT'] = '#/lib/gtest-1.3.0/bin'  # example, optional
	env['LIB_OUTPUT'] = '#/lib/gtest-1.3.0/lib'
	Export('env')
	env.SConscript(env.File('scons/SConscript', gtest_dir))

	env.Append(LIBPATH="#lib/gtest-1.3.0/lib")
	env.Append(LIBS = 'gtest')
	env.Append(CPPPATH="#lib/gtest-1.3.0/include")

def build_tests():
	test_sources = (Glob('test/*.cpp', strings=True) + [x for x in sources if x != "main.cpp"])
	env.Program(target='mixxx-test', source=test_sources)
	Command("../mixxx-test", "./mixxx-test", Copy("$TARGET", "$SOURCE"))

def run_tests():
	ret = Execute("./mixxx-test")
	if ret != 0:
		print "WARNING: Not all tests pass. See mixxx-test output."
		Exit(ret)

flags['test'] = getFlags(env, 'test', 0) or 'test' in BUILD_TARGETS

if int(flags['test']):
	print "Test suite... enabled"
	build_gtest()
	build_flags += 'test '
else:
	print "Test suite... disabled"

# Script Studio
flags['script'] = getFlags(env, 'script', 0)
if int(flags['script']):
	if 'win' in platformString:
		env.Append(LIBS = 'QtScript4')
	elif platformString == 'linux':
		env.Append(LIBS = 'QtScript')
	elif platformString == 'osx':
		#XXX put in logic here to add a -framework QtScript
		#env.Append(
		pass
	print "MixxxScript Studio... enabled"

	build_flags += 'script '
	sources += Split("""script/scriptengine.cpp script/scriptcontrolqueue.cpp
			script/scriptstudio.cpp script/scriptrecorder.cpp
			script/playinterface.cpp script/macro.cpp
			script/scriptcontrolevent.cpp script/trackcontrolevent.cpp
			script/numbercontrolevent.cpp script/numberrecorder.cpp
			script/macrolist.cpp script/trackrecorder.cpp
			script/sdatetime.cpp script/signalrecorder.cpp
			script/macrolistitem.cpp script/qtscriptinterface.cpp""")
	env.Append(CPPPATH = '$QTDIR/include/QtScript')
	env.Append(CPPDEFINES = '__SCRIPT__')

	env.Uic4('script/scriptstudio.ui')
else:
	flags['script'] = 0
	print "MixxxScript Studio... disabled"

# MIDI Scripting
flags['midiscript'] = getFlags(env, 'midiscript', 0)
if int(flags['midiscript']):
	if 'win' in platformString:
		env.Append(LIBS = 'QtScript4')
	elif platformString == 'linux':
		env.Append(LIBS = 'QtScript')
	elif platformString == 'osx':
		#XXX put in logic here to add a -framework QtScript
		#env.Append(
		pass
	print "MIDI Scripting... enabled"

	build_flags += 'midiscript '
	sources += Split("""midi/midiscriptengine.cpp""")
	env.Append(CPPPATH = '$QTDIR/include/QtScript')
	env.Append(CPPDEFINES = '__MIDISCRIPT__')
else:
	flags['midiscript'] = 0
	print "MIDI Scripting... disabled"

# Profiling and Optimization
if platformString == 'linux':
	flags['profiling'] = getFlags(env, 'profiling', 0)
	if int(flags['profiling']):
		env.Append(CCFLAGS = '-pg')
		env.Append(LINKFLAGS = '-pg')
		print "gprof (Linux) profiling support... enabled"
		build_flags += 'profiling '
	else:
		print "gprof (Linux) profiling support... disabled"

if platformString == 'osx':
	flags['profiling'] = getFlags(env, 'profiling', 0)
	if int(flags['profiling']):
		env.Append(CCFLAGS = '-finstrument-functions')
		env.Append(LINKFLAGS = '-lSaturn')
		print "Saturn (OS X) profiling support... enabled"
		build_flags += 'profiling '
	else:
		print "profiling profiling support... disabled"

flags['tuned'] = getFlags(env, 'tuned', 0)
if int(flags['tuned']):
	if not 'win' in platformString:
		ccv = env['CCVERSION'].split('.')
		if int(ccv[0]) >= 4 and int(ccv[1]) >= 2:
			env.Append(CCFLAGS = '-march=native')
			env.Append(LINKFLAGS = '-march=native')
			print "Optimizing for this CPU... yes"
			build_flags += 'tuned '
		else:
			print "Optimizing for this CPU... no (requires gcc >= 4.2.0)"
	else:
		if bitwidth == '64':
			print "Optimizing for this CPU class (" + machine + ")... yes"
			env.Append(CXXFLAGS = '/favor:' + machine)
		else:
			print "Optimizing for this CPU... no (not supported on 32-bit MSVC)"
else:
	if bitwidth == '64':
		if 'makerelease' in COMMAND_LINE_TARGETS:
			print "Optimizing for this CPU class... no  (due to makerelease)"
			# AMD64 is for AMD CPUs, EM64T is for Intel x64 ones (as opposed to IA64 which uses a different compiler.)
			# For a release, we choose to have code run about the same on both
			env.Append(CXXFLAGS = '/favor:blend')

#Specific optimization
flags['optimize'] = getFlags(env, 'optimize', 1)
if int(flags['optimize']):
	if 'win' in platformString:
		if machine == 'AMD64' or machine == 'EM64T':
			env.Append(LINKFLAGS = '/MACHINE:X64')
		else:
			env.Append(LINKFLAGS = '/MACHINE:'+machine)
		if int(flags['msvcdebug']):
			print "Specific optimizations... DISABLED DUE TO DEBUG"
		else:
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags['optimize']) + ' '
			env.Append(CXXFLAGS = '/GL /MP')
			env.Append(LINKFLAGS = '/LTCG:STATUS')
			if flags['optimize']=='1':
				print "  Maximize speed (/O2)"
				env.Append(CXXFLAGS = '/O2')
			elif flags['optimize'] >= '2':
				print "  Maximum optimizations (/Ox)"
				env.Append(CXXFLAGS = '/Ox')
			if not machine == 'AMD64' and not machine == 'EM64T': # SSE and SSE2 are core instructions on x64
				if flags['optimize'] == '3':
					print "  SSE instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE')
				elif flags['optimize'] == '4':
					print "  SSE2 instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE2')
	else:
		if not int(flags['tuned']):
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags['optimize']) + ' '
			env.Replace(CFLAGS = '') # replace CFLAGS and CXXFLAGS with our own optimizations.
			if flags['optimize']=='1':
				env.Replace(CXXFLAGS = '-O3')
			elif flags['optimize']=='2':
				print "  P4 MMX/SSE optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=pentium4 -mmmx -msse2 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='3':
				print "  Intel Core Solo/Duo optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=prescott -mmmx -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='4':
				print "  Intel Core 2 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=nocona -mmmx -msse3 -mfpmath=sse -ffast-math -funroll-loops')
			elif flags['optimize']=='5':
				print "  Athlon Athlon-4/XP/MP optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=athlon-4 -mmmx -msse -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='6':
				print "  Athlon K8/Opteron/AMD64 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8 -mmmx -msse2 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='7':
				print "  Athlon K8/Opteron/AMD64 + SSE3 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8-sse3 -mmmx -msse2 -msse3 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='8':
				print "  Generic SSE/SSE2/SSE3 optimizations enabled (Celeron D)."
				env.Replace(CXXFLAGS = '-O3 -mmmx -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			env.Append(CXXFLAGS = ' ') # add a space to the end of CXXFLAGS
else:
	print "Specific optimizations... disabled"

#Linking with ASMLIB
flags['asmlib'] = getFlags(env, 'asmlib', 0)
if int(flags['asmlib']):
	print "Agner Fog\'s ASMLIB (http://www.agner.org/optimize)... enabled"
	env.Append(LIBPATH='#/../asmlib')
	build_flags += 'asmlib '
	if platformString == 'linux':
		env.Append(CXXFLAGS = '-fno-builtin')   #Use ASMLIB's functions instead of the compiler's
		env.Append(LIBS = '":alibelf' + bitwidth + 'o.a"')
	elif platformString == 'osx':
		env.Append(CXXFLAGS = '-fno-builtin')   #Use ASMLIB's functions instead of the compiler's
		env.Append(LIBS = '":alibmac' + bitwidth + 'o.a"')
	elif 'win' in platformString:
		env.Append(CXXFLAGS = '/Oi-')   #Use ASMLIB's functions instead of the compiler's
		env.Append(LIBS = 'alibcof' + bitwidth + 'o')
	env.Append(CXXFLAGS = ' ') # add a space to the end of CXXFLAGS
else:
	print "Agner Fog\'s ASMLIB (http://www.agner.org/optimize)... disabled"

# SoundTouch Optimizations -- turn them on only if we have SSE or MMX
# enabled. It's dumb that they appear here, but they make the most sense next to
# the optimization stuff. It's safe to assume that if opt > 1, then MMX and SSE
# are enabled. All 64-bit CPUs have MMX and SSE as well.
if bitwidth == '64' or (not 'win' in platformString and int(flags['optimize']) > 1) \
    or ('win' in platformString and int(flags['optimize']) > 2):
    sources += Split("""#lib/""" + soundtouch_path + """/mmx_optimized.cpp #lib/""" + soundtouch_path + """/sse_optimized.cpp""")
    env.Append(CPPDEFINES='ALLOW_X86_OPTIMIZATIONS')

# Enable SoundTouch 3DNow! optimizations for Windows (decides at runtime if they're useful)
if 'win' in platformString and not bitwidth == '64':
    sources += Split("""#lib/""" + soundtouch_path + """/3dnow_win.cpp""")

#Debugging output
flags['qdebug'] = getFlags(env, 'qdebug', 0)
if 'win' in platformString:
	if int(flags['msvcdebug']):
		flags['qdebug'] = 1		# Turn general debugging flag on too if msvcdebug is specified

if int(flags['qdebug']):
	build_flags += 'qdebug '
	print "Debugging message output... enabled"
else:
	env.Append(CPPDEFINES = 'QT_NO_DEBUG_OUTPUT')
	print "Debugging message output... disabled"

#Visual Studio 2005 hacks (MSVS Express Edition users shouldn't enable this)
flags['msvshacks'] = getFlags(env, 'msvshacks', 0)
if int(flags['msvshacks']):
	env.Append(CPPDEFINES = '__MSVS2005__')
	print "MSVS 2005 hacks... enabled"
	build_flags += 'msvshacks '
else:
	print "MSVS 2005 hacks... disabled"

#force 32-bit compile on GCC
'''flags['force32'] = getFlags(env, 'force32', 0)
if int(flags['force32']):
	env.Append(CCFLAGS = '-m32')
	env.Append(CXXFLAGS = '-m32')
	env.Append(LINKFLAGS = '-m32')
	print "Force 32-bit GCC compile... enabled"
else:
	print "Force 32-bit GCC compile... disabled"
'''

#Case Metrics
if 'win' in platformString or platformString == 'linux':
	flags['cmetrics'] = getFlags(env, 'cmetrics', 1)
else:
	flags['cmetrics'] = getFlags(env, 'cmetrics', 0) # Off on OS X for now...
if int(flags['cmetrics']):
	env.Append(CPPDEFINES = '__C_METRICS__')
	if 'win' in platformString:
		env.Append(LIBS = 'cmetrics')
	else:
		client = 'MIXXX'
		server = 'metrics.mixxx.org' # mixxx metrics collector
		Export('env platformString client server flags[\'force32\']')
		env.Append(CPPPATH='#lib/cmetrics')
		sources += SConscript('#lib/cmetrics/SConscript')
	print "Case Metrics profiling... enabled"
	build_flags += 'cmetrics '
else:
	print "Case Metrics profiling... disabled"

#env.Append(CPPDEFINES=[('BUILD_FLAGS', "'%s'" % build_flags)])

### Put flags info into a file
f = open("build.h","a")
try:
	f.write('#define BUILD_FLAGS "' + build_flags + '"\n')
finally:
	f.close()
	

#Tell SCons to build unit tests
if int(flags['test']):
	print "Building tests."
	build_tests()

if 'test' in BUILD_TARGETS:
	print "Running tests."
	run_tests()

#Set up the MSVC target to build a Visual Studio project/solution file
if 'msvc' in COMMAND_LINE_TARGETS:
	includes = map(str, Glob('#src/*.h'))
	includes += map(str, Glob('#src/visual/*.h'))
	#Make the project file aware of any command-line arguments that were passed...
	cmdargs = ""
	for k in SCons.Script.ARGUMENTS:
		cmdargs += " " + k + "=" + SCons.Script.ARGUMENTS[k]
	env.Append(MSVSSCONSFLAGS = cmdargs)
	#env.Append(MSVSSCONSFLAGS = ' qtdir=' + flags['qtdir'])

	# This is the right way to do it but scons is stupid and doesn't copy flags in... Adam
	# Set up environment for debug target
	# TODO Handle lib versions ie /MDd /Md etc...
	#debugenv = env.Clone()
	#debugenv.Prepend(LINKFLAGS = ['/DEBUG','/PDB:dist' + bitwidth + '/mixxx.pdb']) # Generate MS VC Program Debug Database
	#debugenv.Append(CXXFLAGS = '/ZI')

	msvc = env.MSVSProject(target = 'mixxx' + env['MSVSPROJECTSUFFIX'], srcs = sources, incs = includes, variant = 'Debug', runfile = '../dist' + bitwidth + '/mixxx')

	# Reenable this once bug in scons is fixed...
	#msvc = env.MSVSProject(target = 'mixxx' + env['MSVSPROJECTSUFFIX'], srcs = sources, incs = includes, variant = 'Release', runfile = '../dist' + bitwidth + /mixxx')

	env.Alias('msvc', msvc)

# Print the build flags (useful if the flags have been cached, ie. if you just run "scons"
# and want to see the flags that you used last time)
print "================"
print "Building with flags: " + build_flags
print "================\n"

#Save the options to cache
vars.Save(cachefile, env)

Export('env', 'sources', 'flags')
