#!/usr/bin/env python3
"""
generate_piano_sample.py

Generates pianosample.cpp for Mixxx's KeyComparisonEffect.

Usage
-----
# Synthesise a piano-like tone (requires numpy):
    python generate_piano_sample.py

# Use your own WAV file of an A4 piano note (requires numpy + scipy):
    python generate_piano_sample.py --input your_piano_a4.wav

# Custom output path:
    python generate_piano_sample.py --output path/to/pianosample.cpp
"""

import argparse
import math
import sys
from pathlib import Path

import numpy as np


_BASE_FREQ = 440.0
_DURATION_SECONDS = 1.5
_ATTACK_SECONDS = 0.005
_PEAK = 0.88

# (relative_amplitude, decay_rate_per_second) per harmonic,
# starting at fundamental
_HARMONICS = [
    (1.00, 3.0),
    (0.60, 4.5),
    (0.40, 6.0),
    (0.22, 8.0),
    (0.14, 10.0),
    (0.08, 12.0),
    (0.05, 15.0),
    (0.03, 18.0),
    (0.02, 22.0),
]


def _synthesize(sample_rate: int) -> np.ndarray:
    n_samples = int(sample_rate * _DURATION_SECONDS)
    t = np.linspace(0.0, _DURATION_SECONDS, n_samples, endpoint=False)

    wave = np.zeros(n_samples, dtype=np.float64)
    for n, (rel_amp, decay) in enumerate(_HARMONICS, start=1):
        wave += (
            rel_amp
            * np.sin(2.0 * math.pi * n * _BASE_FREQ * t)
            * np.exp(-decay * t)
        )

    attack_samples = max(1, int(sample_rate * _ATTACK_SECONDS))
    wave[:attack_samples] *= np.linspace(0.0, 1.0, attack_samples)

    peak = np.max(np.abs(wave))
    if peak > 1e-9:
        wave *= _PEAK / peak

    return wave.astype(np.float32)


def _load_wav_as_float32_mono(path: Path) -> tuple[np.ndarray, int]:
    try:
        from scipy.io import wavfile
    except ImportError:
        raise RuntimeError(
            "scipy is required to load WAV files: pip install scipy"
        )

    rate, data = wavfile.read(str(path))

    if data.dtype == np.int16:
        data = data.astype(np.float32) / 32768.0
    elif data.dtype == np.int32:
        data = data.astype(np.float32) / 2147483648.0
    elif data.dtype == np.uint8:
        data = (data.astype(np.float32) - 128.0) / 128.0
    elif data.dtype == np.float64:
        data = data.astype(np.float32)
    elif data.dtype != np.float32:
        raise RuntimeError(f"Unsupported WAV sample format: {data.dtype}")

    if data.ndim == 2:
        data = data.mean(axis=1).astype(np.float32)

    return data, rate


def _resample(audio: np.ndarray, src_rate: int, dst_rate: int) -> np.ndarray:
    if src_rate == dst_rate:
        return audio
    try:
        from scipy.signal import resample
    except ImportError:
        raise RuntimeError(
            "scipy is required for resampling: pip install scipy"
        )
    n_out = int(len(audio) * dst_rate / src_rate)
    return resample(audio, n_out).astype(np.float32)


def _trim_and_normalise(audio: np.ndarray, sample_rate: int) -> np.ndarray:
    audio = audio[: int(sample_rate * _DURATION_SECONDS)]
    peak = np.max(np.abs(audio))
    if peak > 1e-9:
        audio = (audio * (_PEAK / peak)).astype(np.float32)
    return audio


def _format_array(name: str, samples: np.ndarray) -> str:
    lines = [f"constexpr CSAMPLE {name}[] = {{"]
    chunk = []
    for i, v in enumerate(samples):
        chunk.append(f"{v:.5f}f")
        if len(chunk) == 8 or i == len(samples) - 1:
            suffix = "," if i < len(samples) - 1 else "};"
            lines.append("        " + ", ".join(chunk) + suffix)
            chunk = []
    return "\n".join(lines)


_CPP_TEMPLATE = """\
// Generated by generate_piano_sample.py — do not edit by hand.
// Re-run the script to regenerate, or pass --input to use a WAV file.
//
// {source_comment}

#include "effects/backends/builtin/pianosample.h"

#include "util/assert.h"

namespace {{

{array_44100}

{array_48000}

{array_96000}

}} // namespace

std::span<const CSAMPLE> pianoSampleForSampleRate(
        mixxx::audio::SampleRate sampleRate) {{
    switch (sampleRate.value()) {{
    case 44100:
        return kPianoSample44100;
    case 48000:
        return kPianoSample48000;
    case 96000:
        return kPianoSample96000;
    default:
        DEBUG_ASSERT(!"Piano sample for this sample rate is missing");
        return kPianoSample44100;
    }}
}}
"""


def generate_cpp(
    audio_44100: np.ndarray,
    audio_48000: np.ndarray,
    audio_96000: np.ndarray,
    source_comment: str,
) -> str:
    return _CPP_TEMPLATE.format(
        source_comment=source_comment,
        array_44100=_format_array("kPianoSample44100", audio_44100),
        array_48000=_format_array("kPianoSample48000", audio_48000),
        array_96000=_format_array("kPianoSample96000", audio_96000),
    )


def main() -> None:
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--input",
        "-i",
        metavar="WAV_FILE",
        help="WAV file containing an A4 (440 Hz) piano note.",
    )
    parser.add_argument(
        "--output",
        "-o",
        metavar="CPP_FILE",
        default="pianosample.cpp",
        help="Output C++ source file (default: pianosample.cpp)",
    )
    args = parser.parse_args()

    if args.input:
        wav_path = Path(args.input)
        if not wav_path.exists():
            print(f"ERROR: File not found: {wav_path}", file=sys.stderr)
            sys.exit(1)
        print(f"Loading WAV file: {wav_path}")
        raw_audio, src_rate = _load_wav_as_float32_mono(wav_path)
        length_s = len(raw_audio) / src_rate
        print(f"  Sample rate : {src_rate} Hz  |  Length : {length_s:.2f} s")

        audio_44100 = _trim_and_normalise(
            _resample(raw_audio, src_rate, 44100), 44100
        )
        audio_48000 = _trim_and_normalise(
            _resample(raw_audio, src_rate, 48000), 48000
        )
        audio_96000 = _trim_and_normalise(
            _resample(raw_audio, src_rate, 96000), 96000
        )
        source_comment = (
            f"Arrays loaded from {wav_path.name} using scipy "
            f"(resampled to 44100, 48000, and 96000 Hz)."
        )
    else:
        print("No input file given — synthesising A4 piano note.")
        audio_44100 = _synthesize(44100)
        audio_48000 = _synthesize(48000)
        audio_96000 = _synthesize(96000)
        source_comment = (
            "Arrays synthetically generated using numpy "
            "(additive harmonic synthesis with"
            " exponential decay per harmonic)."
        )

    out_path = Path(args.output)
    out_path.write_text(
        generate_cpp(audio_44100, audio_48000, audio_96000, source_comment),
        encoding="utf-8",
    )
    print(f"Written → {out_path}  ({out_path.stat().st_size // 1024} KB)")


if __name__ == "__main__":
    main()
